# coding=utf-8
# Copyright 2024 The HuggingFace Team Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a clone of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import unittest

from transformers import LlamaForCausalLM, LlamaForSequenceClassification, LlamaModel
from transformers.models.llama.modeling_llama import LlamaDecoderLayer
from transformers.utils import auto_class_docstring, auto_docstring


LLAMA_CLM_FORWARD = """Args:\n    input_ids (`torch.LongTensor`):\n        Indices of input sequence tokens in the vocabulary. Padding will be ignored by default.\n        Indices can be obtained using `AutoTokenizer`. See `PreTrainedTokenizer.encode` and\n        `PreTrainedTokenizer.__call__` for details.\n\n        [What are input IDs?](../glossary#input-ids)\n    \n    attention_mask (`Optional[torch.Tensor]`) of shape `(batch_size, sequence_length)`:\n        Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n\n        [What are attention masks?](../glossary#attention-mask)\n\n        Indices can be obtained using `AutoTokenizer`. See `PreTrainedTokenizer.encode` and\n        `PreTrainedTokenizer.__call__` for details.\n    \n    position_ids (`Optional[torch.LongTensor]`):\n        Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0, config.n_positions - 1]`.\n\n        [What are position IDs?](../glossary#position-ids)\n    \n    past_key_values (`Union[~cache_utils.Cache, List[torch.FloatTensor], NoneType]`):\n        Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n        blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`\n        returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n\n        Two formats are allowed:\n            - a `~cache_utils.Cache` instance, see our [kv cache guide](https://huggingface.co/docs/transformers/en/kv_cache);\n            - Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of\n            shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`). This is also known as the legacy\n            cache format.\n\n        The model will output the same cache format that is fed as input. If no `past_key_values` are passed, the\n        legacy cache format will be returned.\n\n        If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don't\n        have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`\n        of shape `(batch_size, sequence_length)`.\n    \n    inputs_embeds (`Optional[torch.FloatTensor]`):\n        Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n        is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n        model's internal embedding lookup matrix.\n    \n    labels (`Optional[torch.LongTensor]`) of shape `(batch_size, sequence_length)`:\n        Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n        config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n        (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n    \n    use_cache (`Optional[bool]`):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \n    output_attentions (`Optional[bool]`):\n        Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n        tensors for more detail.\n    \n    output_hidden_states (`Optional[bool]`):\n        Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n        more detail.\n    \n    return_dict (`Optional[bool]`):\n        Whether or not to return a `~utils.ModelOutput` instead of a plain tuple.\n    \n    cache_position (`Optional[torch.LongTensor]`):\n        Indices depicting the position of the input sequence tokens in the sequence. Contrarily to `position_ids`,\n        this tensor is not affected by padding. It is used to update the cache in the correct position and to infer\n        the complete sequence length.\n    \n    num_logits_to_keep (`.int`, defaults to `0`):\n        Calculate logits for the last `num_logits_to_keep` tokens. If `0`, calculate logits for all\n        `input_ids` (special case). Only last token logits are needed for generation, and calculating them only for that\n        token can save memory, which becomes pretty significant for long sequences or large vocabulary size.\n    \n\n    Returns:\n        [`typing.Union`] or `tuple(torch.FloatTensor)`: A [`typing.Union`] or a tuple of\n        `torch.FloatTensor` (if `return_dict=False` is passed or when `config.return_dict=False`) comprising various\n        elements depending on the configuration ([`LlamaConfig`]) and inputs.\n\n"""

LLAMA_MODEL_DOCSTRING = """Args:\n    input_ids (`torch.LongTensor`):\n        Indices of input sequence tokens in the vocabulary. Padding will be ignored by default.\n        Indices can be obtained using `AutoTokenizer`. See `PreTrainedTokenizer.encode` and\n        `PreTrainedTokenizer.__call__` for details.\n\n        [What are input IDs?](../glossary#input-ids)\n    \n    attention_mask (`Optional[torch.Tensor]`) of shape `(batch_size, sequence_length)`:\n        Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n\n        [What are attention masks?](../glossary#attention-mask)\n\n        Indices can be obtained using `AutoTokenizer`. See `PreTrainedTokenizer.encode` and\n        `PreTrainedTokenizer.__call__` for details.\n    \n    position_ids (`Optional[torch.LongTensor]`):\n        Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0, config.n_positions - 1]`.\n\n        [What are position IDs?](../glossary#position-ids)\n    \n    past_key_values (`Union[~cache_utils.Cache, List[torch.FloatTensor], NoneType]`):\n        Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n        blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`\n        returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n\n        Two formats are allowed:\n            - a `~cache_utils.Cache` instance, see our [kv cache guide](https://huggingface.co/docs/transformers/en/kv_cache);\n            - Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of\n            shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`). This is also known as the legacy\n            cache format.\n\n        The model will output the same cache format that is fed as input. If no `past_key_values` are passed, the\n        legacy cache format will be returned.\n\n        If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don't\n        have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`\n        of shape `(batch_size, sequence_length)`.\n    \n    inputs_embeds (`Optional[torch.FloatTensor]`):\n        Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n        is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n        model's internal embedding lookup matrix.\n    \n    use_cache (`Optional[bool]`):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \n    output_attentions (`Optional[bool]`):\n        Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n        tensors for more detail.\n    \n    output_hidden_states (`Optional[bool]`):\n        Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n        more detail.\n    \n    return_dict (`Optional[bool]`):\n        Whether or not to return a `~utils.ModelOutput` instead of a plain tuple.\n    \n    cache_position (`Optional[torch.LongTensor]`):\n        Indices depicting the position of the input sequence tokens in the sequence. Contrarily to `position_ids`,\n        this tensor is not affected by padding. It is used to update the cache in the correct position and to infer\n        the complete sequence length.\n    \n\n    Returns:\n        [`typing.Union`] or `tuple(torch.FloatTensor)`: A [`typing.Union`] or a tuple of\n        `torch.FloatTensor` (if `return_dict=False` is passed or when `config.return_dict=False`) comprising various\n        elements depending on the configuration ([`LlamaConfig`]) and inputs.\n\n"""

LLAMA_DECODER = """Args:\n    hidden_states (`torch.Tensor`): input to the layer of shape `(batch, seq_len, embed_dim)\n    attention_mask (`Optional[torch.Tensor]`) of shape `(batch_size, sequence_length)`:\n        Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n\n        [What are attention masks?](../glossary#attention-mask)\n\n        Indices can be obtained using `AutoTokenizer`. See `PreTrainedTokenizer.encode` and\n        `PreTrainedTokenizer.__call__` for details.\n    \n    position_ids (`Optional[torch.LongTensor]`):\n        Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0, config.n_positions - 1]`.\n\n        [What are position IDs?](../glossary#position-ids)\n    \n    past_key_value (`Optional[~cache_utils.Cache]`):deprecated in favor of `past_key_values`\n    output_attentions (`Optional[bool]`, defaults to `False`):\n        Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n        tensors for more detail.\n    \n    use_cache (`Optional[bool]`, defaults to `False`):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \n    cache_position (`Optional[torch.LongTensor]`):\n        Indices depicting the position of the input sequence tokens in the sequence. Contrarily to `position_ids`,\n        this tensor is not affected by padding. It is used to update the cache in the correct position and to infer\n        the complete sequence length.\n    \n    position_embeddings (`Optional[Tuple[torch.Tensor, torch.Tensor]]`):\n        Tuple containing the cosine and sine positional embeddings of shape `(batch_size, seq_len, head_dim)`,\n        with `head_dim` being the embedding dimension of each attention head.\n    \nReturns: typing.Tuple"""

LLAMA_FOR_SEQUENCE_CLASSIFICATION_DOC = """Args:\n    input_ids (`Optional[torch.LongTensor]`):\n        Indices of input sequence tokens in the vocabulary. Padding will be ignored by default.\n        Indices can be obtained using `AutoTokenizer`. See `PreTrainedTokenizer.encode` and\n        `PreTrainedTokenizer.__call__` for details.\n\n        [What are input IDs?](../glossary#input-ids)\n    \n    attention_mask (`Optional[torch.Tensor]`) of shape `(batch_size, sequence_length)`:\n        Mask to avoid performing attention on padding token indices. Mask values selected in `[0, 1]`:\n\n        - 1 for tokens that are **not masked**,\n        - 0 for tokens that are **masked**.\n\n        [What are attention masks?](../glossary#attention-mask)\n\n        Indices can be obtained using `AutoTokenizer`. See `PreTrainedTokenizer.encode` and\n        `PreTrainedTokenizer.__call__` for details.\n    \n    position_ids (`Optional[torch.LongTensor]`):\n        Indices of positions of each input sequence tokens in the position embeddings. Selected in the range `[0, config.n_positions - 1]`.\n\n        [What are position IDs?](../glossary#position-ids)\n    \n    past_key_values (`Union[~cache_utils.Cache, List[torch.FloatTensor], NoneType]`):\n        Pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention\n        blocks) that can be used to speed up sequential decoding. This typically consists in the `past_key_values`\n        returned by the model at a previous stage of decoding, when `use_cache=True` or `config.use_cache=True`.\n\n        Two formats are allowed:\n            - a `~cache_utils.Cache` instance, see our [kv cache guide](https://huggingface.co/docs/transformers/en/kv_cache);\n            - Tuple of `tuple(torch.FloatTensor)` of length `config.n_layers`, with each tuple having 2 tensors of\n            shape `(batch_size, num_heads, sequence_length, embed_size_per_head)`). This is also known as the legacy\n            cache format.\n\n        The model will output the same cache format that is fed as input. If no `past_key_values` are passed, the\n        legacy cache format will be returned.\n\n        If `past_key_values` are used, the user can optionally input only the last `input_ids` (those that don\'t\n        have their past key value states given to this model) of shape `(batch_size, 1)` instead of all `input_ids`\n        of shape `(batch_size, sequence_length)`.\n    \n    inputs_embeds (`Optional[torch.FloatTensor]`):\n        Optionally, instead of passing `input_ids` you can choose to directly pass an embedded representation. This\n        is useful if you want more control over how to convert `input_ids` indices into associated vectors than the\n        model\'s internal embedding lookup matrix.\n    \n    labels (`Optional[torch.LongTensor]`) of shape `(batch_size, sequence_length)`:\n        Labels for computing the masked language modeling loss. Indices should either be in `[0, ...,\n        config.vocab_size]` or -100 (see `input_ids` docstring). Tokens with indices set to `-100` are ignored\n        (masked), the loss is only computed for the tokens with labels in `[0, ..., config.vocab_size]`.\n    \n    use_cache (`Optional[bool]`):\n        If set to `True`, `past_key_values` key value states are returned and can be used to speed up decoding (see\n        `past_key_values`).\n    \n    output_attentions (`Optional[bool]`):\n        Whether or not to return the attentions tensors of all attention layers. See `attentions` under returned\n        tensors for more detail.\n    \n    output_hidden_states (`Optional[bool]`):\n        Whether or not to return the hidden states of all layers. See `hidden_states` under returned tensors for\n        more detail.\n    \n    return_dict (`Optional[bool]`):\n        Whether or not to return a `~utils.ModelOutput` instead of a plain tuple.\n    \n\n    Returns:\n        [`typing.Union`] or `tuple(torch.FloatTensor)`: A [`typing.Union`] or a tuple of\n        `torch.FloatTensor` (if `return_dict=False` is passed or when `config.return_dict=False`) comprising various\n        elements depending on the configuration ([`LlamaConfig`]) and inputs.\n\n\n    Example of single-label classification:\n\n    ```python\n    >>> import torch\n    >>> from transformers import AutoTokenizer, {model_class}\n\n    >>> tokenizer = AutoTokenizer.from_pretrained("{checkpoint}")\n    >>> model = {model_class}.from_pretrained("{checkpoint}")\n\n    >>> inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")\n\n    >>> with torch.no_grad():\n    ...     logits = model(**inputs).logits\n\n    >>> predicted_class_id = logits.argmax().item()\n    >>> model.config.id2label[predicted_class_id]\n    {expected_output}\n\n    >>> # To train a model on `num_labels` classes, you can pass `num_labels=num_labels` to `.from_pretrained(...)`\n    >>> num_labels = len(model.config.id2label)\n    >>> model = {model_class}.from_pretrained("{checkpoint}", num_labels=num_labels)\n\n    >>> labels = torch.tensor([1])\n    >>> loss = model(**inputs, labels=labels).loss\n    >>> round(loss.item(), 2)\n    {expected_loss}\n    ```\n\n    Example of multi-label classification:\n\n    ```python\n    >>> import torch\n    >>> from transformers import AutoTokenizer, {model_class}\n\n    >>> tokenizer = AutoTokenizer.from_pretrained("{checkpoint}")\n    >>> model = {model_class}.from_pretrained("{checkpoint}", problem_type="multi_label_classification")\n\n    >>> inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")\n\n    >>> with torch.no_grad():\n    ...     logits = model(**inputs).logits\n\n    >>> predicted_class_ids = torch.arange(0, logits.shape[-1])[torch.sigmoid(logits).squeeze(dim=0) > 0.5]\n\n    >>> # To train a model on `num_labels` classes, you can pass `num_labels=num_labels` to `.from_pretrained(...)`\n    >>> num_labels = len(model.config.id2label)\n    >>> model = {model_class}.from_pretrained(\n    ...     "{checkpoint}", num_labels=num_labels, problem_type="multi_label_classification"\n    ... )\n\n    >>> labels = torch.sum(\n    ...     torch.nn.functional.one_hot(predicted_class_ids[None, :].clone(), num_classes=num_labels), dim=1\n    ... ).to(torch.float)\n    >>> loss = model(**inputs, labels=labels).loss\n    ```\n"""


class AutoDocstringTest(unittest.TestCase):
    def test_modeling_docstring(self):
        llama_docstring = (
            "\n        The bare Llama Model outputting raw hidden-states without any specific head on top.\n\n"
        )
        self.assertEqual(llama_docstring, LlamaModel.__doc__)

        self.assertEqual(LLAMA_MODEL_DOCSTRING, LlamaModel.forward.__doc__)
        self.assertEqual(LLAMA_CLM_FORWARD, LlamaForCausalLM.forward.__doc__)
        self.assertEqual(LLAMA_DECODER, LlamaDecoderLayer.forward.__doc__)
        self.assertEqual(LLAMA_FOR_SEQUENCE_CLASSIFICATION_DOC, LlamaForSequenceClassification.forward.__doc__)

    def test_auto_doc(self):
        COOL_CLASS_DOC = """
        Args:
            input_ids (some):
            flash_attn_kwargs (FlashAttentionKwrargs):
                parameters that are completely optional and that should be passed.
            another_warg (something): should pass
            and_another_on (this time):
                I want
                this to be
                quite long

        Example

        ```python
        >>> import
        ```
        """

        @auto_class_docstring
        class MyModel:
            @auto_docstring
            def __init__(input_ids, flash_attn_kwargs=None, another_warg=True, and_another_on=1):
                r"""
                Args:
                    flash_attn_kwargs (FlashAttentionKwrargs):
                        parameters that are completely optional and that should be passed.
                    another_warg (something): should pass
                    and_another_on (this time):
                        I want
                        this to be
                        quite long

                Example

                ```python
                >>> import
                ```
                """
                pass

        self.assertEqual(MyModel.__init__.__doc__, COOL_CLASS_DOC)
